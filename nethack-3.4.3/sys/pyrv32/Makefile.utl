#	Cross-compilation Makefile for NetHack utilities (RV32 target)
#	Generates utilities that run on the pyrv32 simulator
#
#	Strategy:
#	  1. Use host bison/flex to generate C source files
#	  2. Cross-compile those C files for RV32 using picolibc
#	  3. Link with firmware syscalls for file I/O

# Cross-compilation toolchain
CC = riscv64-unknown-elf-gcc
ARCH_FLAGS = -march=rv32im -mabi=ilp32

# Paths
FIRMWARE_DIR = ../../firmware
PICOLIBC_INC = /usr/lib/picolibc/riscv64-unknown-elf/include
PICOLIBC_LIB = /usr/lib/picolibc/riscv64-unknown-elf/lib/rv32im/ilp32

# Compiler flags for RV32
CFLAGS = $(ARCH_FLAGS) -O2 -g -Wall \
         -I../include \
         -I../../firmware/include \
         -isystem $(PICOLIBC_INC) \
         -ffunction-sections -fdata-sections \
         -DPYRV32

# Linker flags
LDFLAGS = $(ARCH_FLAGS) \
          -T$(FIRMWARE_DIR)/link.ld \
          -L$(PICOLIBC_LIB) \
          -Wl,--gc-sections \
          -Wl,-Map=$@.map \
          -nostartfiles -nodefaultlibs

LIBS = -lc -lgcc

# Startup and syscall support
CRT0 = $(FIRMWARE_DIR)/crt0.o
SYSCALLS = $(FIRMWARE_DIR)/syscalls.o

# yacc/lex programs (run on HOST to generate C source)
YACC = bison -y
LEX = flex
YTABC = y.tab.c
YTABH = y.tab.h
LEXYYC = lex.yy.c

# ----------------------------------------
# Target executables (RV32 binaries)
# ----------------------------------------

all: makedefs.bin lev_comp.bin dgn_comp.bin

# ----------------------------------------
# makedefs - generates header files and data files
# ----------------------------------------

MAKEOBJS = makedefs.o monst.o objects.o

makedefs.elf: $(MAKEOBJS) $(CRT0) $(SYSCALLS)
	$(CC) $(LDFLAGS) -o $@ $(CRT0) $(SYSCALLS) $(MAKEOBJS) $(LIBS)

makedefs.bin: makedefs.elf
	riscv64-unknown-elf-objcopy -O binary $< $@
	@echo "Built makedefs.bin (RV32)"

makedefs.o: makedefs.c
	$(CC) $(CFLAGS) -c $<

monst.o: ../src/monst.c
	$(CC) $(CFLAGS) -c $<

objects.o: ../src/objects.c
	$(CC) $(CFLAGS) -c $<

# ----------------------------------------
# lev_comp - level compiler
# ----------------------------------------

LEVOBJS = lev_yacc.o lev_lex.o lev_main.o \
          alloc.o panic.o drawing.o decl.o monst.o objects.o

lev_comp.elf: $(LEVOBJS) $(CRT0) $(SYSCALLS)
	$(CC) $(LDFLAGS) -o $@ $(CRT0) $(SYSCALLS) $(LEVOBJS) $(LIBS)

lev_comp.bin: lev_comp.elf
	riscv64-unknown-elf-objcopy -O binary $< $@
	@echo "Built lev_comp.bin (RV32)"

# Generate C source from yacc/lex (runs on HOST)
lev_yacc.c: lev_comp.y
	$(YACC) -d lev_comp.y
	mv $(YTABC) lev_yacc.c
	mv $(YTABH) ../include/lev_comp.h

lev_lex.c: lev_comp.l
	$(LEX) lev_comp.l
	mv $(LEXYYC) lev_lex.c

# Compile generated C for RV32
lev_yacc.o: lev_yacc.c
	$(CC) $(CFLAGS) -c $<

lev_lex.o: lev_lex.c ../include/lev_comp.h
	$(CC) $(CFLAGS) -DWEIRD_LEX=0 -c $<

lev_main.o: lev_main.c
	$(CC) $(CFLAGS) -c $<

# ----------------------------------------
# dgn_comp - dungeon compiler
# ----------------------------------------

DGNOBJS = dgn_yacc.o dgn_lex.o dgn_main.o \
          alloc.o panic.o

dgn_comp.elf: $(DGNOBJS) $(CRT0) $(SYSCALLS)
	$(CC) $(LDFLAGS) -o $@ $(CRT0) $(SYSCALLS) $(DGNOBJS) $(LIBS)

dgn_comp.bin: dgn_comp.elf
	riscv64-unknown-elf-objcopy -O binary $< $@
	@echo "Built dgn_comp.bin (RV32)"

# Generate C source from yacc/lex (runs on HOST)
dgn_yacc.c: dgn_comp.y
	$(YACC) -d dgn_comp.y
	mv $(YTABC) dgn_yacc.c
	mv $(YTABH) ../include/dgn_comp.h

dgn_lex.c: dgn_comp.l
	$(LEX) dgn_comp.l
	mv $(LEXYYC) dgn_lex.c

# Compile generated C for RV32
dgn_yacc.o: dgn_yacc.c
	$(CC) $(CFLAGS) -c $<

dgn_lex.o: dgn_lex.c ../include/dgn_comp.h
	$(CC) $(CFLAGS) -DWEIRD_LEX=0 -c $<

dgn_main.o: dgn_main.c
	$(CC) $(CFLAGS) -c $<

# ----------------------------------------
# Shared object files
# ----------------------------------------

alloc.o: ../src/alloc.c
	$(CC) $(CFLAGS) -c $<

panic.o: panic.c
	$(CC) $(CFLAGS) -c $<

drawing.o: ../src/drawing.c
	$(CC) $(CFLAGS) -c $<

decl.o: ../src/decl.c
	$(CC) $(CFLAGS) -c $<

# ----------------------------------------
# Utilities
# ----------------------------------------

clean:
	rm -f *.o *.elf *.bin *.map

clean-generated:
	rm -f lev_yacc.c lev_lex.c dgn_yacc.c dgn_lex.c
	rm -f ../include/lev_comp.h ../include/dgn_comp.h

# ----------------------------------------
# Installation targets
# ----------------------------------------
#
# WORKFLOW:
#   1. Generate files once in simulator (expensive, ~50M+ instructions per utility)
#      - Simulator: fs_root=/home/dev/git/pyrv32/pyrv32_sim_fs/, working_dir=dat/
#      - Utilities write to ../dat/ → /home/dev/git/pyrv32/pyrv32_sim_fs/dat/
#   
#   2. Archive to nethack_datafiles (master repository, done once)
#      - make archive: copies pyrv32_sim_fs/dat/ → nethack_datafiles/
#   
#   3. Install to runtime location (repeatable, enables clean installs)
#      - make install: copies nethack_datafiles/ → pyrv32_sim_fs/usr/games/lib/nethackdir/
#
# This allows regenerating the simulator rootfs without re-running expensive utilities.
#

# Source: nethack_datafiles (master archive of generated files)
DATAFILES_DIR = ../../nethack_datafiles/usr/games/lib/nethackdir

# Destination: pyrv32_sim_fs runtime location
SIMFS_ROOT = ../../pyrv32_sim_fs
SIMFS_NETHACKDIR = $(SIMFS_ROOT)/usr/games/lib/nethackdir

# Temporary generation location (used during initial generation only)
SIMFS_DAT = $(SIMFS_ROOT)/dat

# ----------------------------------------
# archive: Copy generated files to master repository (run once after generation)
# ----------------------------------------
archive: archive-data archive-dungeon archive-levels

archive-data:
	@mkdir -p $(DATAFILES_DIR)
	@echo "Archiving makedefs generated data files to $(DATAFILES_DIR)..."
	@if [ -f $(SIMFS_DAT)/data ]; then cp $(SIMFS_DAT)/data $(DATAFILES_DIR)/; echo "  data"; fi
	@if [ -f $(SIMFS_DAT)/rumors ]; then cp $(SIMFS_DAT)/rumors $(DATAFILES_DIR)/; echo "  rumors"; fi
	@if [ -f $(SIMFS_DAT)/oracles ]; then cp $(SIMFS_DAT)/oracles $(DATAFILES_DIR)/; echo "  oracles"; fi
	@if [ -f $(SIMFS_DAT)/quest.dat ]; then cp $(SIMFS_DAT)/quest.dat $(DATAFILES_DIR)/; echo "  quest.dat"; fi
	@if [ -f $(SIMFS_DAT)/options ]; then cp $(SIMFS_DAT)/options $(DATAFILES_DIR)/; echo "  options"; fi

archive-dungeon:
	@mkdir -p $(DATAFILES_DIR)
	@echo "Archiving dgn_comp generated dungeon to $(DATAFILES_DIR)..."
	@if [ -f $(SIMFS_DAT)/dungeon ]; then cp $(SIMFS_DAT)/dungeon $(DATAFILES_DIR)/; echo "  dungeon"; fi

archive-levels:
	@mkdir -p $(DATAFILES_DIR)
	@echo "Archiving lev_comp generated levels to $(DATAFILES_DIR)..."
	@for lev in $(SIMFS_DAT)/*.lev; do \
		if [ -f "$$lev" ]; then \
			cp "$$lev" $(DATAFILES_DIR)/; \
			echo "  $$(basename $$lev)"; \
		fi \
	done

# ----------------------------------------
# install: Copy from master repository to simulator runtime location (repeatable)
# ----------------------------------------
install: install-data install-dungeon install-levels install-static

install-data:
	@mkdir -p $(SIMFS_NETHACKDIR)
	@echo "Installing data files from $(DATAFILES_DIR) to $(SIMFS_NETHACKDIR)..."
	@if [ -f $(DATAFILES_DIR)/data ]; then cp $(DATAFILES_DIR)/data $(SIMFS_NETHACKDIR)/; echo "  data"; fi
	@if [ -f $(DATAFILES_DIR)/rumors ]; then cp $(DATAFILES_DIR)/rumors $(SIMFS_NETHACKDIR)/; echo "  rumors"; fi
	@if [ -f $(DATAFILES_DIR)/oracles ]; then cp $(DATAFILES_DIR)/oracles $(SIMFS_NETHACKDIR)/; echo "  oracles"; fi
	@if [ -f $(DATAFILES_DIR)/quest.dat ]; then cp $(DATAFILES_DIR)/quest.dat $(SIMFS_NETHACKDIR)/; echo "  quest.dat"; fi
	@if [ -f $(DATAFILES_DIR)/options ]; then cp $(DATAFILES_DIR)/options $(SIMFS_NETHACKDIR)/; echo "  options"; fi

install-dungeon:
	@mkdir -p $(SIMFS_NETHACKDIR)
	@echo "Installing dungeon file from $(DATAFILES_DIR) to $(SIMFS_NETHACKDIR)..."
	@if [ -f $(DATAFILES_DIR)/dungeon ]; then cp $(DATAFILES_DIR)/dungeon $(SIMFS_NETHACKDIR)/; echo "  dungeon"; fi

install-levels:
	@mkdir -p $(SIMFS_NETHACKDIR)
	@echo "Installing level files from $(DATAFILES_DIR) to $(SIMFS_NETHACKDIR)..."
	@for lev in $(DATAFILES_DIR)/*.lev; do \
		if [ -f "$$lev" ]; then \
			cp "$$lev" $(SIMFS_NETHACKDIR)/; \
			echo "  $$(basename $$lev)"; \
		fi \
	done

install-static:
	@mkdir -p $(SIMFS_NETHACKDIR)
	@echo "Installing static help files from ../dat to $(SIMFS_NETHACKDIR)..."
	@for file in cmdhelp help hh history license opthelp wizhelp; do \
		if [ -f ../dat/$$file ]; then \
			cp ../dat/$$file $(SIMFS_NETHACKDIR)/; \
			echo "  $$file"; \
		fi \
	done

.PHONY: all clean clean-generated archive archive-data archive-dungeon archive-levels install install-data install-dungeon install-levels install-static
